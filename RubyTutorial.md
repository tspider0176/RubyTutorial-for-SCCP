# 課外プロジェクト 2015 実践的プログラミング II
2015 10/29 渡部未来・齊藤智博
資料URL: https://github.com/tspider0176/RubyTutorial-for-SCCP

## 1 はじめに
### 1.1 言語について
Rubyは日本人、まつもとゆきひろ(通称Matz)の手によって開発されたオブジェクト指向スクリプト言語である。
現在C言語を習っている受講生にとってはオブジェクト指向だとかスクリプト言語という言葉はまだまだ聞きなれないかもしれない。
しかし、2年生前期・後期で習うJAVA1やC++は、両方ともオブジェクト指向言語である。
授業で習うまでの事前知識として今から簡単な特徴だけでも頭に入れておいて損は無いだろう。

__オブジェクト指向言語__  


__スクリプト言語__  

### 1.2 対話型シェル REPL、ソースコード実行
今まで授業でC言語を触ってきて、あるライブラリの関数の仕様を知りたい！といった時に苦労した経験は無いだろうか？ある関数の挙動を試す時に、変数宣言、目的の関数呼び出し、ソースコード保存、コンパイル、実行、出力確認...そこまでやって間違えていてまた最初からやり直しなどと言った日にはディスプレイを窓から投げ捨てて帰宅したくなるものだ。  
そんな時、Rubyプログラマーは、対話型Rubyシェルを用いることができる。これはREPL(Read-eval-print loop, れぷる)と呼ばれており、英単語から分かる通り、読んで(read)、評価して(eval)、表示して(print)、繰り返す(loop)シェルプログラムである。コードをシェルに打ち込むと直ちにそれを評価し表示してくれるので、前出のC言語の時のようにプログラミングを行っている時に関数の挙動を確かめたりしたい時などに手軽に確認出来る。  
さて、実際にREPLを起動してみよう。ターミナル上で以下のコマンドを打ち込むことによって起動出来る。

```
$ irb
```
下のような文字がコンソール上に表示されたら起動した証拠だ。

```
irb(main):001:0>
```

それでは実際にシェル上に

```
irb(main):001:0> 1+1
```
と打ち込んでみよう。

```
=> 2
```

と結果が返ってくるはずだ。これだけではただの計算機だが、Rubyの基本構文等は全てこのREPL上で実行、表示する事が出来る。もちろんテキストファイルを作成しコードを記述してコンパイル、と言った手順でも動作確認が可能だが、今後の章で紹介するコードは殆ど小規模な物なのでREPL上で動作を確認した方が手軽で良いだろう。  
終了するにはCtrl-Dを入力するか、exitまたはquitとキーボードから入力すれば良い。  

実際にAOJの問題を解く時など比較的大きなプログラムを組むことになる場合に備えて、ソースコードをファイルに記述した場合の実行方法を教える。適当なテキストエディタを開き、実際にRubyのHello Worldを書いてみよう。

```
// ターミナル上で
$ mkdir Ruby
$ cd Ruby
$ emacs hello.rb
```

上から分かる通り、Rubyプログラムの拡張子は.rbである。

```
//テキストエディタ上で
puts "Hello World"
```

上のコードを追加してファイルを保存しよう。Rubyソースコードをコンパイルするにはターミナル上で、

```
$ ruby hello.rb
```

と実行すれば良い。これらを使って実際にAOJのHello world問題を解いてみよう。  
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_1_A  
また今後AOJのITP問題でRubyを学習する為にも、前回習ったgitをここで復習してみるのも良いだろう。

```
$ mkdir AOJwithRuby
$ cd AOJwithRuby
$ for i in `seq -w 1 10`; do mkdir ITP${i}; done
// gitのコマンドを復習しよう！
```

## 2 制御式
### 2.1 式とは？
C言語の制御「文」とは違い、rubyでは制御「式」と言う呼び方が使われている。
以下の節でざっくり説明しよう。

### 2.2 if式
#### 2.2.1 構文
rubyにおけるif式の基本的な構文は以下の形になる。

```
# Rubyにおけるif式
if [条件式] then
	[被制御式]
end

# 複数条件ある時のif式 (elseif ではないことに注意！)
if [条件式1] then
  [被制御式1]
elsif [条件式2] then
  [被制御式2]
elsif ...
...
else
  [被制御式n]
end
```

条件式と被制御式部分が明確に分離可能な場合はthenは省略出来る。先の章で式とは値を返す物だと説明したが、if式の場合は被制御式の最後に評価された式の値を返す。  
  もし条件分岐先の処理が至極単純であり、長々とif式を書くのが煩わしいと感じる人はif修飾子を用いて以下のように書くことができる。

```
# if制御式の書き方
[被制御式] if [条件式]
```

また、rubyにはunless式という制御構文が実装されており、その名の通り条件式が偽の時に被制御式を評価する。

```
# unless構文
unless [条件式] then
  [被制御式]
end

# if式と同じくunless修飾子を使うことが出来る。
[被制御式] unless [条件式]
```

#### 2.2.2 コード例とC言語のif文との違い
AOJの問題を例にif式の使い方を紹介しよう。  
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_2_A

```
# C言語の模範的解答
if(a < b) printf("a < b\n");
else if(a > b) printf("a > b\n");
else printf("a == b\n");
```

これはC言語におけるifが"文"である事に忠実な書き方だが、rubyにおけるifは"式"であり、"値を返す"という事を考慮すると、以下のようなコードが考えられる。

```
# Rubyでの解答一例
print(
  if a == b then "a = b"
  else "a != b"
  end
)
```

また、前節最後で紹介したif修飾子を用いた書き方をすると、よりスマートな書き方が可能になる。

```
# Rubyのif修飾子とunless修飾子を用いた解答
print "a = b" if a == b
print "a != b" unless a == b
```

以上の説明でなんとなく理解が出来たら、理解を確実にするためにAOJの以下の問題を解いてみよう。
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_2_B

### 2.3 case式
#### 2.3.1 構文
rubyにおけるcase式は、C言語におけるswitch-case文に相当するものであり、値による多岐分岐を提供してくれている。

```
# Rubyのcase式
case [変数]
when [値] then
  [処理]
when [値] then
  [処理]
...
else
  [処理]
end
```

上のcase式では、まずcaseの後に置かれた[変数]が評価され、次にその値に対応するwhen節が選ばれた後にthen節が実行され、最後に評価された式がcase式全体の値になり、返却される。このcase式もif式と同じく、区切りが明確であればthenは省略可能である。

#### 2.3.2 コード例とC言語のswitch-case文との違い
例えば、以下の問題を少し簡単にして、指定された演算子によって整数同士の計算結果を一回だけ出力するようにしよう。
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_4_C  

```
# 今回はこちらから値を指定する
a=810
b=19
op = "+"

# 演算子によって返す値を変え、出力
puts(
  case op
  when "+" then
    a + b
  when "-" then
    a - b
  when "*" then
    a * b
  when "/" then
    a / b
  else
    "error"
  end
)
```
上記の実行結果はもちろん以下になる。

```
829 => nil
```

このように、C言語のswitch-case文と殆ど動作は変わらない。

### 2.4 while式
#### 2.4.1 構文
C言語でも登場したループを表す制御構文のうち、本節ではwhlie式を紹介する。while式はrubyの中で最も単純な繰り返し構造であり、条件式が成立している間、被制御ぶの式を繰り返し評価し続ける。while式は以下のように書くことが出来る。

```
# Rubyのwhile式、doは省略可能
while [条件式] do
  [被制御部]
end

# if式などと同様にwhile修飾子が存在している。
[被制御部] while [条件式]
```

C言語の授業では詳しく習わなかったかもしれないが、C言語で言うdo_whileに対応する制御文もrubyには存在する。こちらは名前が後置whileと名前が変わっているが、動作そのものはC言語と全く同じである。構文は以下になる。

```
# do_whileと同じ動作をする式
begin
  [被制御部]
end while [条件式]
```

このように記述する事によって、コード中に存在する被制御部は最低一回実行されてから、条件式の条件が成立しているか評価が行われ、通常のwhileループと同じ動きをするようになる。また、if文にもunlessという否定形の構文が存在したが、whileにもuntilと呼ばれている否定形の制御式が存在し、もちろんdo_untilとuntil修飾子もある。

```
until [条件式]
  [被制御部]
end

# 最低一回被制御部を実行するdo_until文
begin
  [被制御部]
end until [条件式]

# until修飾子
[被制御部] until [条件式]
```

ここまでwhile式の構文を提示してきたが、while"式"という言葉なのにもかかわらず、今まで式として返す値について言及しなかったのには理由がある。実はrubyにおけるwhile式は確かに値を返しているのだが、nilという値を返している。このnilというものはオブジェクトが存在しないことを示しているのだが、これでは今までのように構文を値として使うことが出来ない。今の段階では不便に感じることは無いかもしれないが、オブジェクト指向に於いて意味のある値を返さない関数というのは副作用がある関数と言い、あまり推奨されていない。
すぐにとは言わないが、rubyではなるべくwhile式を用いないようなコーディングを心がけるようにしよう。

#### 2.4.2 コード例
この節ではwhileの基本的な使い方をAOJの問題を例に紹介しよう。一番単純な問題としては、以下のAOJが良い例だろう。  
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_3_A  
rubyでの模範的な回答は以下になる。

```
# while式を用いた解法
i = 0
while i < 1000
  print "Hello World\n"
  i = i+1
end

# until式を用いた解法
i = 1000
until i > 0
  print "Hello World\n"
  i = i-1
end
```

### 2.5 for式
#### 2.5.1 構文
最後に、for式を説明しよう。この式はC言語などで用いる場面と同じく、配列の操作などに長けている。以下にその構文を示す。

```
# doは省略可能
for [変数] in [オブジェクト] do
  [被制御部]
end
```

inの後にある[オブジェクト]にはループ対象のRange型オブジェクトや配列そのものが入る。for式ではあらかじめ指定したオブジェクトから要素を全て取り出すと繰り返しは終了するので、特に終了条件をこちらから与えてあげる必要はない。  
C言語と違い、rubyのfor文は繰り返し処理の制御構造に於いてそこまで重要な立ち位置を占めていない。と言うのも、for式の中でも実際にはイテレータを呼び出しており、より繰り返し構造を深く理解するにはイテレータを理解した方が良いだろう。

#### 2.5.2 コード例
実際にfor文を用いて繰り返し処理を実行してみよう。
例えば、1から10までの和を求めるfor式は以下のようになる。

```
# 1から10までの和をfor式で求める
sum = 0
for i in 1..10 do
  sum = i + 1
end
```

## 3 配列
ここで配列について扱うことに疑問を覚える人も居るかもしれない。しかし、Rubyにおける配列はオブジェクトであり、C言語と一線を画す独特な仕様が配列に適用されている。それにより、今までに習ってきた言語に比べて格段に魅力的な物となっているのだ。  
データの集合を扱うような問題が出題された時、どう行ったアプローチで問題を解決へ導くだろうか？例えばC言語だったら、for文でループの添字を用いてうまく処理を行ったり、はたまたwhile文で処理を行う人も居るかもしれない。では、Rubyの場合データの集合に対してどのようなアプローチが可能なのか？  
Rubyの配列は基本的にはC言語と変わらない。しかし、C言語では領域外参照で実行時エラーとなっていたマイナスの添字が可能となっていたり、その他とても便利なメソッドが追加されている。

```
// Rubyの配列に於けるマイナスの添字は配列の末尾からの数を表している
p c[-1] #=> " 文字列" c[c.length-1]と等価
p c[-2] #=> 3 c[c.length-2]と等価
p c[-5] #=> nil 最初の要素よりも前。範囲外。
```
最初に書いたように、Rubyにおける配列とはオブジェクトである。オブジェクトは、自身の事をよく知っているし、様々な手段を用いて操作をする事ができる。例えば以下に例を挙げるが、実際にREPL上で実行ながら読み進めてみると良いだろう。
```
array = ["a", "b", "c"]
p array.length #=> 3
p array.size #=> 3 (length の同義語)
p array *= 2 #=> ["a", "b", "c", "a", "b", "c"]
p array.include? "c" #=> true 特定の値を含むかどうか
p array.sort #=> ["a", "a", "b", "b", "c", "c"] 新しい配列を生成して返す
p array #=> ["a", "b", "c", "a", "b", "c"] 元の配列は変化していない
p array.uniq #=> ["a", "b", "c"] 重複要素を削除した配列を生成して返す
array.uniq! # 元の配列自体を更新する。
p array #=> ["a", "b", "c"]
```

今まで配列のサイズを知るためには、for文でループを回して添字の数で知る若干面倒な方法を取ってきたと思う。しかしこのメソッド達によって、煩わしい手段が簡略化され、より他のプログラミング、設計に時間を割く事が可能となった。これらの書法は見慣れないもので最初は戸惑うかもしれないが、是非少しずつ慣れていって、是非プログラミングに最良な手段を身につけて貰いたい。

## 4 ハッシュ
今まではデータと数値の関係をプログラム中で記述するには配列を用いていた。しかし、あくまでもそれは操作対象が数値の時くらいであり、"ある人物とその人の年齢"だとか、はたまた要素が数値ですらない"授業の名前と担当教授"だとか言った関係は記録が出来ない。そんな時に用いるのがハッシュである。ハッシュとは、任意のオブジェクトをキーとして別のオブジェクトに対応付けるコンテナオブジェクトである。ハッシュの要素は、*キー(key)* となるオブジェクトから *値(value)* となるオブジェクトへの対応関係を持っている。具体例を以下に示そう。

```
humane_studies ={
	"Philosophy" => "Ohta",
	"Logic" => "Aoki",
	"Psychology" => "Kikuchi",
	"Linguistics" => "Shimada",
	"Arts" => "Kakeda",
	"Law" => "Seino"
}
```
上のハッシュをREPL上で宣言して、実際に以下のコマンドを打ってハッシュの挙動を確かめてみよう。

```
# キーを指定して、値を参照する
p humane_studies["Philosophy"]  # => "Aoki"
# 存在しないキーの場合
p humane_studies["Linear Algebra"] #=> nil
# 既存のキーの更新
p humane_studies["Philosophy"] = ["Ohta", "Aoki"]
# 新しいキーの登録
book_to_author["Written expression"] = "Sawa"
```

もちろんハッシュにも、特有のメソッドが存在する。これは配列の場合とよく似ており、例えば、Hash#map はブロックを評価した結果を集めて配列を作成する。

```
p humane_studies.map{|lec,prof|
  "#{lec} by #{prof}"
}
# 下の値が帰ってくる
# => ["Philosophy by Ohta", "Logic by Aoki", "Psychology by Kikuchi", "Linguistics by Shimada", "Arts by Kakeda", "Law by Seino"]
```

ここでは紹介しきれないが、メソッドはこれ以外にも複数あるので是非調べてみよう。
前節、本節で紹介したこれらのデータ型を用いれば、C言語で苦労した様々な問題に対する別の解法が得られるだろう。

## 参考資料
初めてのRuby O'REILLY Japan　Yugui著  
http://www.oki-osk.jp/esc/ruby/tut-01.html  
http://docs.ruby-lang.org/ja/2.0.0/doc/index.html  
